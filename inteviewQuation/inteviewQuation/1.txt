/*
1. React Class Component Lifecycle
React lifecycle is divided into three main phases:
Mounting â€“ when component is created and inserted into the DOM.
Updating â€“ when component is re-rendered due to state or prop changes.
Unmounting â€“ when component is removed from the DOM.


ğŸ”¹ How it maps to Function Components

Mounting â†’ useEffect(() => { ... }, [])
Updating â†’ useEffect(() => { ... }, [dependencies])
Unmounting â†’ useEffect(() => { return () => { ... } }, []) ==thatâ€™s one of the main reasons we use the cleanup function in useEffect!


  useEffect(() => {
    const interval = setInterval(() => {
      setCount(prev => prev + 1);
    }, 1000);

    // Cleanup on unmount
    return () => {
      clearInterval(interval); // prevent memory leak
      console.log("Component unmounted, timer cleared");
    };
  }, []);

  return <h1>Count: {count}</h1>;
}


ğŸ”¹ Summary
Unmounting cleanup in useEffect is essential for memory management and avoiding errors.
Always clean up timers, listeners, subscriptions, and async callbacks in the return function.

*/



/*


optimizing React performance â€” perfect, this is super important for large apps.


| Technique         | Purpose                                            |
| ----------------- | -------------------------------------------------- |
| Lazy Loading      | Load components only when needed                   |
| React.memo        | Prevent unnecessary re-renders of child components |
| useMemo           | Memoize expensive calculations                     |
| useCallback       | Memoize functions to avoid re-creation             |
| Virtualization    | Efficiently render long lists                      |
| Code Splitting    | Reduce initial bundle size                         |
| Avoid extra state | Donâ€™t store derived data in state                  |



               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚   React Performance Boosters   â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                         â”‚                         â”‚
  â–¼                         â–¼                         â–¼
Lazy Loading          Memoization              Virtualization
(Load only when       (Avoid re-renders)       (Efficient lists)
needed)                      â”‚                         â”‚
   â”‚                         â”‚                         â”‚
React.lazy + Suspense   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        react-window /
Code Splitting          â”‚ React.memo    â”‚        react-virtualized
Dynamic Imports         â”‚ useMemo       â”‚
                        â”‚ useCallback   â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚   Other Best Practices       â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚ - Avoid unnecessary state
          â”‚ - Avoid anonymous functions in JSX
          â”‚ - Split bundles (webpack / vite)
          â”‚ - Use Profiler to find bottlenecks
          â”‚ - Debounce/throttle expensive events



useMemo
What it does: Memoizes a value (result of a calculation).
When to use: When you have an expensive calculation you donâ€™t want to re-run on every render.

useCallback
What it does: Memoizes a function (its reference).
When to use: When passing functions to memoized child components to prevent unnecessary re-renders.

*/